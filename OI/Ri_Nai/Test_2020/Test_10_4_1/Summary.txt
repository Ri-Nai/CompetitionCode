这次考试考得还行,吸取了前两次考试的教训,前两题都打了对拍
为什么T3不打对拍?因为完全不会写暴力(QAQ)

T1原本想倍增的,但是想了想快速幂好像也行
T2没得出证明,但是结论很显然,和我的BFS+DFS的双重暴力代码也都能完美拍下
T3有用的边就是能够保证联通而且权值最大的边---最小生成树
但是这是一棵森林,用Kruskal用剩下的并查集维护联通就好
对于每棵树上求路径上的最小值就可以了,和树上交易那道题差不多(其实更简单)

暴力的并查集做法好像就是建最小生成树的过程中回答询问,怎么想都想不到
然后就可以用按秩合并的并查集或者询问启发式合并优化了吧

T4考试的时候是打了50分的切分,但是好像是n==500的点挂掉了
暴力做法相当暴力 先用bitset维护u,v两条路径是否相交//直接暴力找LCA
存到一个m^2的mark数组里,再用状压枚举状态
总时间复杂度大概是(2^m*m^2+一些零零碎碎的东西)
我以为这勉强能冲的,但是冲不过去,就挂掉了

正解是dp,整场考试下来都在想贪心,都没想到过dp的可能性,失策了

dp转移方程比较难想,但是写出来就是比较简单了
对于一个LCA,有选取一条路径或不选这条路径的情况,不选自然就是选儿子路径之和
选了的话就是这条链下面的儿子之和+w
可以存一个sum,表示它的儿子的dp之和,相当于前缀和吧
一个节点sum[u]-dp[u]会减掉它父亲的加上的dp[u]值
a-b-c-d-e五个点为一条链 c为LCA
就有sum[a]-dp[a]+sum[b]-dp[b]+sum[c]+sum[d]-dp[d]+sum[e]-dp[e]
sum[e]->∑dp[son]
sum[d]->|dp[e]|+∑dp[son]
sum[c]->|dp[b]|+|dp[d]|+∑dp[son]
sum[b]->|dp[a]|+∑dp[son]
sum[a]->∑dp[son]

减去dp[a],dp[b],dp[c],dp[d]就是纯正的∑dp[son]了